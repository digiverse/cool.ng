/*
 * Copyright (c) 2017 Leon Mlakar.
 * Copyright (c) 2017 Digiverse d.o.o.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. The
 * license should be included in the source distribution of the Software;
 * if not, you may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * The above copyright notice and licensing terms shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */

#include <iostream>
#include <typeinfo>
#include <memory>
#include <stack>
#include <functional>
#include <atomic>
#include <mutex>
#include <thread>
#include <chrono>
#include <cstdio>
#include <cstdlib>
#include <condition_variable>
#include <exception>

#if !defined(WINDOWS_TARGET)
# include <sys/types.h>
# include <sys/socket.h>
#endif

#define BOOST_TEST_MODULE NetworkEventSources
#include <boost/test/unit_test.hpp>

#include "cool/ng/bases.h"
#include "cool/ng/async.h"

// #include "test_server.h"

using ms = std::chrono::milliseconds;

#define DELAY 100000

BOOST_AUTO_TEST_SUITE(net_sources)

class test_runner : public cool::ng::async::runner
{
 public:
  test_runner()       { clear(); }
  void inc()          { ++m_counter; }
  void clear()        { m_counter = 0; }
  int counter() const { return m_counter; }

 private:
  int m_counter = 0;
};

BOOST_AUTO_TEST_CASE(accept_test)
{
#if 0
  std::mutex m;
  std::condition_variable cv;
  bool connected = false;

  auto r = std::make_shared<test_runner>();
  auto server = async::net::server(
      std::weak_ptr<test_runner>(r)
    , ipv4::any
    , 22222
    , [&m, &cv, &connected](const std::shared_ptr<test_runner>& r
                          , const net::handle h
                          , const ip::address& a
                          , int p)
      {
        if (r)
          r->inc();

        std::cout << "Connect from [" << static_cast<std::string>(a) << "]:" << p << "\n";
        std::unique_lock<std::mutex> l(m);
        connected = true;
        cv.notify_one();
        return true;
      }
  );

  server.start();

  std::unique_lock<std::mutex> l(m);
  cv.wait_for(l, ms(DELAY), [&connected]() { return connected;});
  BOOST_CHECK_EQUAL(1, r->counter());
#endif
  std::cout << "hello, world\n";
}


BOOST_AUTO_TEST_SUITE_END()




































#if 0
class test_runner : public cool::ng::async::runner
{
 public:
  test_runner()       { clear(); }
  void inc()          { ++m_counter; }
  void clear()        { m_counter = 0; }
  int counter() const { return m_counter; }

 private:
  int m_counter = 0;
};

std::size_t read_data(cool::ng::io::handle fd_, std::size_t size)
{
  char arr[200];
  return recv(fd_, arr, sizeof(arr), 0);
}

BOOST_AUTO_TEST_CASE(reader_basic)
{
  std::mutex m;
  std::condition_variable cv;
  bool client_connected = false;
  std::size_t received_data = 0;

  auto server = test::test_server::create(
      18576
      // on accept
    , [&m, &cv, &client_connected]()  // on_accept
      {
        std::unique_lock<std::mutex> l(m);
        client_connected = true;
        cv.notify_one();
      }
      // on receive
    , [&m, &cv, &received_data](cool::ng::io::handle fd_, std::size_t size_)
      {
        std::unique_lock<std::mutex> l(m);
        received_data += read_data(fd_, size_);
        if (received_data >= 1024)
          cv.notify_one();
      }
    , [](){}  // on_write_complete
      // on disconnect
    , [&m, &cv, &client_connected]()
      {
        std::unique_lock<std::mutex> l(m);
        client_connected = false;
        cv.notify_one();
      }
  );

  std::unique_lock<std::mutex> l(m);

  auto client = test::test_client::create(
      18576
    , [](cool::ng::io::handle fd_, std::size_t){} // on_receive
    , [](){}  // on_write_complete
  );

  cv.wait_for(l, ms(DELAY), [&client_connected]() { return client_connected; });
  BOOST_CHECK_EQUAL(true, client_connected);
  std::cout << "Connected\n";

  // at this point client is connected, now send some data
  {
    unsigned char data[1024];
    client->write(42, data, sizeof(data));
  }
  cv.wait_for(l, ms(DELAY), [&received_data]() { return received_data != 0; });
  BOOST_CHECK_EQUAL(1024, received_data);
  std::cout << "Received " << received_data << " bytes of data\n";

  // disconnect client and wait for server to notice
  client.reset();

  cv.wait_for(l, ms(DELAY), [&client_connected]() { return !client_connected; });
  std::cout << "Disconnected\n";

  BOOST_CHECK_EQUAL(false, client_connected);
}
#endif
